\documentclass[10pt,a4paper]{article}			%format de page
\usepackage[utf8]{inputenc}						%encodage avec caractères accentués
\usepackage[T1]{fontenc}						%encodage
\usepackage[english,frenchb]{babel}						%typographie française
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts,amssymb}
\usepackage{xcolor}
\usepackage{pict2e}
\usepackage{tikz} %Dessins
% Mise en page
\usepackage{geometry}
\geometry{a4paper,twoside,left=2.5cm,right=2.5cm,top=2.8cm,bottom=2.8cm} %taille et marges
\pagestyle{fancy}								%style de page {fancy(package), empty, plain, headings}
\renewcommand{\headrulewidth}{0pt}				%épaisseur du trait de tête de page (0.4pt)
\fancyhead[L]{}									%pied de page gauche
\fancyhead[C]{}									%pied de page centre
\fancyhead[R]{}									%pied de page droit
\renewcommand{\footrulewidth}{0pt}				%épaisseur du trait du pied de page (0.4pt)
\fancyfoot[L]{}									%pied de page gauche
\fancyfoot[C]{}									%pied de page centrce
\fancyfoot[R]{\thepage{}/\pageref{LastPage}}	%pied de page droit

\thispagestyle{empty}				% Page de garde vide

% Infos générales
\title{Symmetry Detection}
\author{Chantal DING, Chloé MACUR}
\begin{document}

\selectlanguage{english}

\input{une}
\newpage
\tableofcontents

\newpage
	
	\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}
  
	A lot of 3D shapes, whether natural or man-made, present some kind of symmetry that can be really useful in computer vision and 3D geometry.  Indeed symmetries allow certain economy, especially in digital representation, but they are also involved in pattern recognition or geometry completion. Thus, numerous methods are used to detect symmetries, partly because of the diversity of datas (point clouds, polygon meshes, NURBS, patches, etc.).  
 
	\section{A Planar-Reflective Symmetry Transform for 3D Shapes}
	
	We chose to try to implement the planar reflective symmetry transform (PRST) described by Podolak et al.~\cite{Podolak:2006:APS}. This transform takes a 3D shape and aims at getting the space of planes that are associated to a reflectional symmetry. It provides both global symmetries, certain local symmetries and even imperfect symmetries. Moreover, it is not sensitive to noise or missing data. For a proper understanding of this method, we transcribe here some of the formulas used.\\
	
	Given a function $f$ representing the energy, $PRST(f,\gamma)$ is a measure of $f$'s symmetry with respect to the plane reflection $\gamma$.
	The symmetry distance, $SD(f,\gamma)$ is defined as the $L_2$ distance between $f$ and the nearest function that is invariant to that reflection:
	\begin{displaymath}
	SD(f,\gamma) = min_{g|\gamma(g)=g} \lVert f-g \lVert . %TODO afficher en dessous
	\end{displaymath}

Which leads, by normalizing the symmetry measure, to
$$ PRST^2(f,\gamma) = 1 - \frac{SD^2(f,\gamma)}{\lVert f \lVert ^2}	 $$

However, the nearest symmetric function to $f$ is the average of $f$ and $\gamma(f)$:
$$ SD(f,\gamma) = \lVert f - \frac{f + \gamma(f)}{2} \lVert = \frac{\lVert f - \gamma(f) \lVert }{2} $$

Therefore, we have:
$$ PRST^2(f,\gamma) = 1 - \frac{SD^2(f,\gamma)}{\lVert f \lVert ^2} =  1 - \frac{\lVert f - \gamma(f) \lVert ^2 }{4 \lVert f \lVert ^2}	=  1 - \frac{\lVert f \lVert ^2 - 2f.\gamma(f) + \lVert \gamma(f) \lVert ^2 }{4 \lVert f \lVert ^2} $$

If $f$ is normalized, we obtain
$$ PRST^2(f,\gamma) = \frac{1 + f.\gamma(f)}{2} $$

	Thus, to evaluate the symmetry measure for a plane, we need to evaluate the following estimator, called Monte Carlo estimator :
$$ D(f,\gamma) = f.\gamma(f). $$
	
	To compute this PRST we chose to use a Monte Carlo algorithm, which computes a discrete version of the PRST that takes advantage of sparsity in the function $f$. This sparsity is mostly found in  point sets and rasterized surfaces.
	The brute force approach would be to evaluate the PRST for every single plane in the space of the figure. That would be done by selecting a pair of points and voting for the plane between them. Instead of chosing the points randomly, we favour the points corresponding to a high energy of function $f$.\\
	

\indent \indent \textbf{for} sampled points $x$:\\
\indent \indent \indent \textbf{for} sampled points $x'$: \\
\indent \indent \indent \indent $\gamma \leftarrow$ reflection plane($x, x'$)\\
\indent \indent \indent \indent $D(f,\gamma) += w(x, x',\gamma).f(x).f(x')$\\
	
Moreover we do not vote for planes but discretized bins of planes and we weight the vote of each pair of points:
$$ w(x, x',\gamma) = w_{samp} . w_{change-of-variables} $$

$w_{samp}$ is the reciprocal of the probability of having selected the two points :
$$w_{samp}(x, x',\gamma) = \frac{1}{f(x).f(x')}. $$

The $change-of-variables$ is due to the fact that we move from a pair of points to discretized bins represented by polar coordinates. In 3D spherical coordinates, it is given by the formula \[w_{change-of-variables} = 2d^2\sin\theta\]
where $\theta$ is the angle of the bin from the origin.\\

This leads to $$ w(x, x',\gamma) = \frac{1}{f(x)f(x')2d^2\sin\theta}. $$

In the end, we obtain $$D(f,\gamma) = \frac{1}{N_{samp}} \sum_{i=1}^{N_{samp}}\frac{1}{2d^2\sin\theta}$$


	
	\section{Our implementation}
	
	%TODO delete before saving
	\textit{· 2 page description of your implementation. Here you should describe the main building blocks of your implementation. We are especially interested in: whether you had any problems, whether there were things not mentioned in the paper that you had to discover or derive yourself (be very explicit about your own work!), whether you used any external libraries, etc. What we're not interested in: what are the names of your classes and variables, what operating system you were using, if you had to change some header files, etc. Whenever possible (which is most of the time), please try to use images instead of text to explain concepts.\\
	Your project should include some amount of independent work, either by implementing a technique and showing its performance on some examples not included by the authors, or by doing some independent theoretical analysis.\\}

	\subsection {Conventions and Notations}
We chose to use classic image formats (png, jpg) as input files as they are naturally rasterized. For more simplicity we only considered grayscale images. Since the method we are implementing is taking advantage of sparsity in the function, a typical input image would be a black and white outline (see Figure \ref{exemple_carre}). The Java class \texttt{BufferedImage} provides an easy way to access such images and manipulate them as arrays of integers between 0 and 255. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{img/carre.png}
\caption{Example of input image}
\label{exemple_carre}
\end{center}
\end{figure}

Since pixel values are high for white and low for black, we want to work with the function $f$ defined as follows for each pixel $p$ of the image $I$ :
\[f(p) = 255 - \text{intensity of $I$ at $p$}\]
so that $f(p)=0$ for white pixels, i.e. empty space.

For point coordinates, we simply use the default Java coordinate system, with $(0,0)$ in the upper-left corner, as shown in Figure \ref{coordinates}. All points have integer coordinates. Lines however, are parametrized over a pair of \texttt{double} values $(r,\theta)$ where $|r|$ is the distance of the line to the origin and $\theta$ the angle of the normal vector, as shown in Figure \ref{lines_parametrization}. $theta$ is in $(-\frac{\pi}{2},\frac{\pi}{2}]$ and $r$ can be negative.\\

\begin{figure}[h]
\input{figCoord}
\caption{$(x,y)$ coordinates for Java images}
\label{coordinates}	
\end{figure}

\begin{figure}[h]	
\input{figLines}	
\caption{$(r,\theta)$ parametrization of lines}
\label{lines_parametrization}
\end{figure}

	\subsection{Sampling}
In order to compute the PRST using the Monte Carlo algorithm for sparse functions, we first perform an importance sampling of points in the image, using $f(x)$  as the probability density of selecting $x$. For this, we use the cumulative sum of $f(x)$ over the image as the cumulative distribution function and perform an inverse transform sampling. Usually, this method works by generating a real number $u$ in range [0,1] and computing $F^{-1}(u)$, where $F$ is a cumulative distribution function. Here, we adapted the method to work with non-normalized integer functions :
\begin{enumerate}
\item Generate a random integer n in range $[0,max_F]$, where $F$ is the cumulative sum of pixel values and $max_F$ its maximum value;
\item Let $p_1,...,p_N$ be the pixels of the image, compute $i=\inf\{m\in \mathbb{N}, m\leq N |  F(p_m) = n\}$;
\item Add $p_m$ to the sample.
\end{enumerate}



	\subsection{Adjustments for 2D}
	
\textit{	the polar issue, formulas different, etc...\\}

The Monte Carlo algorithm we chose to use for computing the PRST requires to derive a change-of-variable weight for each pair of points $(x,x')$, accounting for the transformation between the discrete parametrization of lines over $(r,\theta)$ and the pairs of reflected points. In 3D, the change-of-variables weight is given by the following formula :
\[w_{change-of-variables} = 2d^2\sin\theta\]
However, since we are working in 2D, we need to recompute this weight in order to fit the new coordinates system. As in 3D, we compute the determinant of the Jacobian of the change-of-variables transformation. Let 
\[\vec{n}=\begin{pmatrix}\cos\theta \\ \sin\theta\end{pmatrix}\]
be the normal of the line of reflection, $d$ the distance between $x$ and $x'$, we can write :
\begin{align*}
 d & = \lVert x-x' \rVert  \\
& = 2(r-\vec{n}\cdot x) \\
x' &= x+ d\vec{n}\\
&= x+ 2(r\vec{n} - (\vec{n}\cdot x)\vec{n})
\end{align*}
thus we have :
\begin{align*}
\frac{\partial x'}{\partial r}&=2\vec{n}\\
\frac{\partial x'}{\partial \theta}&= 2r\vec{u}-2[(\vec{u}\cdot x)\vec{n}+(\vec{n}\cdot x)\vec{u}]
\end{align*}
where 
\[\vec{u}=\frac{\partial \vec{n}}{\partial \theta} = \vec{n}=\begin{pmatrix}-\sin\theta \\ \cos\theta\end{pmatrix}.\]
Therefore, the Jacobian is
\[J = 2
\begin{pmatrix}
\cos\theta & -r\sin\theta-(\vec{u}\cdot x)\cos\theta+(\vec{n}\cdot x)\sin\theta\\
\sin\theta &  r \cos\theta - (\vec{u}\cdot x)\sin\theta - (\vec{n}\cdot x)\cos\theta
\end{pmatrix}\]
and so the determinant is
\[w_{change-of-variables} = |J| = 2d.\]

  	\subsection{Comments}
  	Choice of the 1/N factor in the calculus of D : explain that it comes out of the blue ... \\
  	
  	Bounds : la valeur du prst (monte carlo) obtenue telle qu'on le fait dépend complètement de l'unité de longueur qu'on utilise pour calculer les distance x,x'. Du coup on n'a vraiment aucune garantie sur les bornes du prst Monte Carlo, contrairement au prst complet...\\
  	
  	
  	\section{Results}
  		%TODO delete before saving
\textit{· 1.5-2 pages of results. Show (especially in, graphs, screenshots, etc.) the results that you have obtained. Comment on discrepancies (if any) with the results shown in the paper. Comment on whether you had to tweak parameters to get good results and, if so, how you picked them.\\}

	\section{Possible extensions}
	
\textit{· 0.5-1 pages of possible extensions. Can you suggest how the method can be improved? Can you suggest other application domains for your method?\\}

	\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}

\addcontentsline{toc}{section}{References} 
\nocite{*}
\bibliographystyle{plain}
\bibliography{bibli}
		
\end{document}
